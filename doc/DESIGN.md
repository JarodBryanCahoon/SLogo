 * In this design pattern, our view, the frontend, communicates directly with the design's controller in order to parse commands and pass information back and forth. The container class of the frontend  (in some ways, the "controller" of the frontend) is our ViewModule, whereas the Manager class in the backend is our nominal controller. These two classes contain instances of each other, which allows ease of communication. In addition, all of the submodules contained within the ViewModule follow the observer-observable design pattern in observing the Manager class and updating accordingly. With regards to direct interaction with the controller, the frontend has the ability to pass user inputted commands into the backend, to receive the validity of the command from the backend, etc.
        * An example of a use case involving communication between the View and the Controller includes passing a user input command to the controller, which decides whether or not what the user passed in is a valid command. If the user passed in a valid command, the controller would add the command to the history and pass it back to the view to be displayed; in addition, it would pass the command to the View in an interaction described later. If the user passed in a command that was syntactically invalid, the controller would tell the frontend to display this error in a user friendly way (in this case, the text box the user was entering commands into would be highlighted in red). 
    * In addition to direct communication between View and Controller, communication between the Controller and the Model must also be direct. The Controller must be able to act on the model or tell the model to act in a specific way. To accomplish this, the Controller must contain all instances of the model that are being actively used in the program (in this case, all active or inactive turtles). In addition, the Model must be able to accept the correction action from the Controller in the form of a Command object. Furthermore, the Model must, in the acceptance of this Command object and through the Command's execution, allow the model to both access and alter the Model's state. In our implementation, each command was separated into its own class in order maintain flexibility and ease in extensibility, as all that is created for the addition of a new command is the creation of a new class that extends the superclass already implemented. Implementing every command as a method inside the turtle is NOT feasible and violates the Open Closed Principle (open for extension and closed for modification); midway through the project, I asked backend to refactor their code because every command was being implemented as a separate method in the turtle because the reflection in the tree parsing would be easier. I believe that this method takes a very narrow view of how the project was to be done and in many ways did not consider how the project would be extended if one were to try and use our code outside the narrow parameters of our class project. In our implementation, the backend turtle (named Turtle) does not need to pass any information back to the model; instead, Turtle updates itself and its corresponding frontend RenderSprite, which is an interaction described later.
        * An example of a use case would be the user calling fd fd 50 on a turtle. Once the Controller has created the abstract syntax tree and the appropriate commands to be passed to the turtle, the turtle is passed the Command objects that are to be executed; subsequently, the turtle calls the execute method on the Command object by passing itself to the execute method (the advantage of this convolution will be described later). This is the interface in which the turtle's state will be updated (twice in this case), and the Command object will modify the turtle's state to represent a fd fd 50 command's execution. (Shown below, where TurtleNode is a Command object)