* At a high level, our program follows the Model-View-Controller design pattern. This design pattern provides a clear delineation of duties between the object being manipulated (the model), the user interface which is displaying this model (the view), and the logic that is actually manipulating the model (the controller). In addition, this design pattern also allows for a clear separation between the frontend and backend. The model itself is split into two parts: a "backend" Turtle class that contains the logic for command execution, and a "frontend" RenderSprite class that contains the logic for displaying the turtle (more generally, sprite image) including animations, translation from javafx coordinates to logo coordinates, etc. 
 * In this design pattern, our view, the frontend, communicates directly with the design's controller in order to parse commands and pass information back and forth. The container class of the frontend  (in some ways, the "controller" of the frontend) is our ViewModule, whereas the Manager class in the backend is our nominal controller. These two classes contain instances of each other, which allows ease of communication. In addition, all of the submodules contained within the ViewModule follow the observer-observable design pattern in observing the Manager class and updating accordingly. With regards to direct interaction with the controller, the frontend has the ability to pass user inputted commands into the backend, to receive the validity of the command from the backend, etc.
        * An example of a use case involving communication between the View and the Controller includes passing a user input command to the controller, which decides whether or not what the user passed in is a valid command. If the user passed in a valid command, the controller would add the command to the history and pass it back to the view to be displayed; in addition, it would pass the command to the View in an interaction described later. If the user passed in a command that was syntactically invalid, the controller would tell the frontend to display this error in a user friendly way (in this case, the text box the user was entering commands into would be highlighted in red). 
    * In addition to direct communication between View and Controller, communication between the Controller and the Model must also be direct. The Controller must be able to act on the model or tell the model to act in a specific way. To accomplish this, the Controller must contain all instances of the model that are being actively used in the program (in this case, all active or inactive turtles). In addition, the Model must be able to accept the correction action from the Controller in the form of a Command object. Furthermore, the Model must, in the acceptance of this Command object and through the Command's execution, allow the model to both access and alter the Model's state. In our implementation, each command was separated into its own class in order maintain flexibility and ease in extensibility, as all that is created for the addition of a new command is the creation of a new class that extends the superclass already implemented. Implementing every command as a method inside the turtle is NOT feasible and violates the Open Closed Principle (open for extension and closed for modification); midway through the project, I asked backend to refactor their code because every command was being implemented as a separate method in the turtle because the reflection in the tree parsing would be easier. I believe that this method takes a very narrow view of how the project was to be done and in many ways did not consider how the project would be extended if one were to try and use our code outside the narrow parameters of our class project. In our implementation, the backend turtle (named Turtle) does not need to pass any information back to the model; instead, Turtle updates itself and its corresponding frontend RenderSprite, which is an interaction described later.
        * An example of a use case would be the user calling fd fd 50 on a turtle. Once the Controller has created the abstract syntax tree and the appropriate commands to be passed to the turtle, the turtle is passed the Command objects that are to be executed; subsequently, the turtle calls the execute method on the Command object by passing itself to the execute method (the advantage of this convolution will be described later). This is the interface in which the turtle's state will be updated (twice in this case), and the Command object will modify the turtle's state to represent a fd fd 50 command's execution. (Shown below, where TurtleNode is a Command object)
    * What is left is the interaction between the Model and the frontend View. As stated above, the Model is divided into a backend Turtle and a frontend RenderSprite, where, loosely, the former handles state changes from passed in commands and the latter handles the movement, animations, etc of these state changes. In the above use case, only the backend Turtle's state has been altered; what remains is updating the frontend RenderSprite. To do this, we employ the Observer Observable pattern. In simple use cases, the only implementation of this pattern is the RenderSprite observer observing the observable Turtle; however, since many of our use cases are more complex than a simple command pass, the Turtle and the RenderSprite both observe each other. When the Turtle calls act on a command object passed in, it calls update on its observers. As a result, the frontend RenderSprite reads in the Turtle's state values and updates itself accordingly. Note that the fact that the RenderSprite and the Turtle observe each other means that the user can also change the Turtle's state from the frontend/user interface (ie through drag and drop, setting through TurtleView, etc.).
